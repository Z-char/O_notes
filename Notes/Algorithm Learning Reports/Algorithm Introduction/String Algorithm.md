### kmp 算法
kmp 算法是用来解决 $s$ 和 $t$ 两个串的匹配的，更准确来说，我们的问题是求 $s$ 里面出现了多少个 $t$。
那么最朴素的暴力肯定是：
```cpp
for (int i = 0; i < s.len; ++i) { // 枚举 s 从哪里和 t 匹配
	for (int j = 0; j < t.len; ++j) { // 枚举如何和 t 匹配
		if (s[i + j] != t[i + j]) {
			break;
		}
		if (j == t.len - 1) {
			ans += 1;
		}
	}
}
```
这是从 "匹配" 的视角去描述的，我们发现这个或许可以优化，但是我认为 kmp 的本质是从另一个视角去描述 "匹配"。
现在，我们假设定义一个 dp，有 $dp_s(i)$ 表示 $s$ 串从 $i$ 开始，最长有多长的一个后缀可以和 $t$ 的前缀匹配，也就是我们想求最大的一个 $k$，满足 $s[i-k+1, i] = t[1, k]$，这里的记号表示字符串取 $l$ 到 $r$ 的字符构成的子串，举例来说，`abcbcbc` 的 $[2, 5]$ 就是从第二个字符 $b$ 到第五个字符 $c$，即 `bcbc`。
那么这个 dp 的暴力如下：
```cpp
for (int i = 0; i < s.len; ++i) {
	for (int j = t.len; j >= 0; --j) {
		bool flg = true;
		for (int p1 = i - j + 1, p2 = 0, k = 0; k < j; ++k, ++p1, ++p2) {
			if (s[p1] != t[p2]) {
				flg = false;
				break;
			}
		}
		if (flg) {
			dp[i] = j;
			break;
		}
	}
}
```
你可能会说欸这个复杂度不是不减反增了吗，别急，首先我们注意到有 `dp[i] <= dp[i - 1] + 1`。
![[attachments/Pasted image 20240731114632.png]]
看图，如果有 `dp[i] > dp[i - 1] + 1`，那么把 $s[i]$ 和 $t[dp[i]]$ 同时去掉，我们发现原来的 `dp[i - 1]` 和定义不同，并不是对应的最大值，所以矛盾了。
欸于是我们不禁开始思考，那能不能用 `dp[i - 1]` 转移 `dp[i]` 呢，如果 $s[i] = t[dp[i-1]+1]$ 自然有 `dp[i] = dp[i - 1] + 1`，也就是达到了我们的上界，那么如果不等于呢。
不等于的话，我们不希望暴力的枚举所有 `dp[i - 1]` 以下的长度了，于是我们想，如何保留一个最长的可行解。
![[attachments/Pasted image 20240731115436.png]]
假设最后的答案是下面那个串，比 `dp[i-1]+1` 要短，我们看看这个串有没有什么特征，欸，我们注意到下面那个串是从 1 开始，匹配到 `i-1` 位置时，对应上面的字符应该是 $t[dp[i-1]]$。
![[attachments/Pasted image 20240731115652.png]]
也就是说红色的段应该相等，这是因为他们都能匹配同一段 $s$ 串。
![[attachments/Pasted image 20240731115721.png]]
进一步观察蓝色的串也应该相等，欸所以这个答案串满足什么？他一定是 `dp[i-1]` 匹配的串的一个前缀！还是和其后缀相等的一个前缀！等等，让我们回顾一下我们一开始 `dp` 的定义。
>有 $dp_s(i)$ 表示 $s$ 串从 $i$ 开始，最长有多长的一个后缀可以和 $t$ 的前缀匹配

那么是不是我们定义 $dp_t(i)$ 表示 $t$ 串从 $i$ 开始，最长有一个多长的后缀能和 $t$ 的前缀匹配，这样 `dp[i-1]` 就可以跳到 `dpt[dp[i-1]]` 这个位置，我们发现一直跳，就会遍历完所有 `dp[i-1]` 串的 "和对应后缀匹配的" 前缀，也就是所有可能成为答案的那个串，所以假设我们求出了这个 `dpt` 数组，暴力就可以写成下面的东西了：
```cpp
// 这里改成 1-index 因为好写
for (int i = 1; i <= s.len; ++i) {
	for (int j = dp[i - 1]; j >= 0; j = dpt[j]) {
		if (s[i] == t[j + 1]) {
			dp[i] = j + 1;
			break;
		}
	}
}
```
注意到这个 `dp[i]` 啊，每次至多增加 1，所以 `j` 往回跳次数不会超过 `n`，于是这个暴力已经是线性的了。
那么如何求 `dpt` 数组呢？哦，原来和这个定义一样，只需要将 $t$ 看作 $s$ 串做这个 dp 就行了，这样 dp 就是 dpt 数组本身，所以就是：
```cpp
for (int i = 1; i <= t.len; ++i) { // 这里要把匹配串变成 t 哦
	for (int j = dpt[i - 1]; j >= 0; j = dpt[j]) { // 这里的 dp 变成 dpt
		if (t[i] == t[j + 1]) { // 这里注意也改成 t
			dpt[i] = j + 1; // 这里的 dp 变成 dpt
			break;
		}
	}
}
```
所以其实匹配本身就是 kmp dp，kmp dp 自己也是 kmp dp，上面的自己 dp 之所以对，是因为我们证明了之前的是对的，我们现在只需要证明 `dpt[i]` 会从 `dpt[j] + 1` 转移过来，其中 $j < i$ 即可，也就是为了保证没有后效性，这是显然的，因为一开始是从 `i-1`，后来 `i-1` 越变越小，当然都 $\lt i$。证毕。
